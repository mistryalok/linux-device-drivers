/*  simpMod.c - The simplest kernel module.
 *  The device will be controlled like this
 *  on the character device put something like this
 *  "2,2,+"
 *  echo "2,2,+" > /dev/tutDevice
 * 	Then on the sysfs/class/CLASS_TUT/parCrtl, put "="
 *  echo "=" > /sysfs/class/CLASS_TUT/parCrtl
 */
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

#include <linux/uaccess.h>
#include <linux/cdev.h>
#include <linux/fs.h>

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("simpMod - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "simpMod"
#define CLASS_NAME "CLASS_TUT"

    
/*
 ********************* Custom Driver starts
 */
static char ker_buf[100];
static int currLen = 0;
// Parts of the math operation (2,2,+) is 2+2
static char math_operation;
static int operand_1 = 0;
static int operand_2 = 0;
static int result = 0;
static int resp_ready = 0;
static struct class *driver_class = NULL;
static dev_t first;
static struct cdev c_dev; // Global variable for the character device
static struct device *ourDevice;

// Pointer to the IP registers
volatile unsigned int *regA;
volatile unsigned int *regB;
volatile unsigned int *regOp;
volatile unsigned int *regC;
volatile unsigned int *regCrtl;

/*
 ********************** Custom Driver ends
 */

// Structure to hold device specific data
struct simpMod_local {
	int irq;
	unsigned long mem_start;
	unsigned long mem_end;
	void __iomem *base_addr;
};


/*
 ********************** Custom Driver starts
 */
// Character callbacks prototype
static int dev_open(struct inode *inod, struct file *fil);
static ssize_t dev_read(struct file *fil, char *buf, size_t len, loff_t *off);
static ssize_t dev_write(struct file *fil, const char *buf, size_t len, loff_t *off);
static int dev_release(struct inode *inod, struct file *fil);

void ipStart(void) {
	unsigned int data = (*regCrtl & 0x80);
	*regCrtl = (data | 0x01);
}

unsigned int ipIsDone(void) {
	unsigned int data = *regCrtl;
	return ((data >> 1) & 0x1);	
}

// Control the execution of the IP core
static ssize_t writeSomeAttr(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	printk(KERN_ALERT "Received %d bytes attribute %s\n",(int)count,buf);
	if (count > 0) {
		if (buf[0] == '='){
			printk(KERN_ALERT "Calculate something op1:%d op2:%d operation:%c\n"
				    ,operand_1,operand_2,math_operation);
			resp_ready = 1;
			switch (math_operation) {
			case '+': {
				*regOp = 0;				
				break;
			}
			case '-': {
				*regOp = 1;				
				break;
			}
			case '*': {
				*regOp = 2;				
				break;
			}
			case '/': {
				*regOp = 3;				
				break;
			}
			default:
				*regOp = 0;
			}			
			// Start the IP core and wait for result
			printk(KERN_ALERT "Start IP core\n");
			ipStart();
			while(!ipIsDone());
			printk(KERN_ALERT "IP core done\n");			
			result = *regC;			
			printk(KERN_ALERT "Result is: %d\n",*regC);
		}
	}
	return count;
}

static ssize_t readSomeAttr(struct device *dev, struct device_attribute *attr, 
							char *buf)
{
    int isBusyResp = ipIsDone();
    sprintf(buf, "Busy is:%d\n", isBusyResp);
    return strlen(buf)+1; 
}

// Define an attribute "parCrtl" (it will expanded to dev_attr_"parCrtl"
// Define an attribute "isBusy" (it will expanded to dev_attr_"isBusy"
static DEVICE_ATTR(parCrtl, S_IWUSR, NULL, writeSomeAttr);
static DEVICE_ATTR(isBusy, S_IRUGO, readSomeAttr, NULL);


static struct file_operations fops = {
		.read=dev_read,
		.write=dev_write,
		.open=dev_open,
		.release=dev_release,
};
/*
 ********************** Custom Driver ends
 */


static irqreturn_t simpMod_irq(int irq, void *lp){
	printk("simpMod interrupt\n");
	return IRQ_HANDLED;
}

static int simpMod_probe(struct platform_device *pdev){
	struct resource *r_irq; /* Interrupt resources */
	struct resource *r_mem; /* IO mem resources */
	struct device *dev = &pdev->dev;	
	static struct simpMod_local *lp = NULL;
	int rc = 0;

	printk("Device Tree Probing\n");

	// Get data of type IORESOURCE_MEM(reg-addr) from the device-tree
	// Other types defined here:
	// http://lxr.free-electrons.com/source/include/linux/ioport.h#L33
	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!r_mem) {
		dev_err(dev, "invalid address\n");
		return -ENODEV;
	}

	// Allocate memory (continuous physical)to hold simpMod_local struct
	lp = (struct simpMod_local *) kmalloc(sizeof(struct simpMod_local), GFP_KERNEL);
	if (!lp) {
		printk("Cound not allocate simpMod device\n");
		return -ENOMEM;
	}

	dev_set_drvdata(dev, lp);

	// Save data on simpMod_local strucutre
	lp->mem_start = r_mem->start;
	lp->mem_end = r_mem->end;

	// Ask the kernel the memory region defined on the device-tree and
	// prevent other drivers to overlap on this region
	// This is needed before the ioremap
	if (!request_mem_region(lp->mem_start,
				lp->mem_end - lp->mem_start + 1,
				DRIVER_NAME)) {
		dev_err(dev, "Couldn't lock memory region at %p\n",
			(void *)lp->mem_start);
		rc = -EBUSY;
		goto error1;
	}

	// Get an virtual address from the device physical address with a 
	// range size: lp->mem_end - lp->mem_start + 1
	lp->base_addr = ioremap(lp->mem_start, lp->mem_end - lp->mem_start + 1);
	if (!lp->base_addr) {
		dev_err(dev, "simpMod: Could not allocate iomem\n");
		rc = -EIO;
		goto error2;
	}		
	// ****************** NORMAL Device diver *************************
	// register a range of char device numbers
	if (alloc_chrdev_region(&first, 0, 1, "Leonardo") < 0){
		printk(KERN_ALERT "alloc_chrdev_region failed\n");
		return -1;
	}
	
	// Create class (/sysfs)
	driver_class = class_create(THIS_MODULE, CLASS_NAME);
	if (driver_class == NULL) {
		printk(KERN_ALERT "Create class failed\n");
		unregister_chrdev_region(first, 1);
		return -1;
	}
	
	ourDevice = device_create(driver_class, NULL, first, NULL, "tutDevice");
	if ( ourDevice == NULL){
		printk(KERN_ALERT "Create device failed\n");
		class_destroy(driver_class);
		unregister_chrdev_region(first, 1);
		return -1;
	}	

	// Create a character device /dev/tutDevice
	cdev_init(&c_dev, &fops);
	if (cdev_add(&c_dev, first, 1) == -1){
		printk(KERN_ALERT "Create character device failed\n");
		device_destroy(driver_class, first);
		class_destroy(driver_class);
		unregister_chrdev_region(first, 1);
		return -1;
	}

	// Create the attribute file on /sysfs/class/CLASS_TUT/ called 
	// parCrtl and isBusy
	if (device_create_file(ourDevice, &dev_attr_parCrtl) < 0){
		printk(KERN_ALERT "Attribute device creation failed\n");
		return -1;
	}
	if (device_create_file(ourDevice, &dev_attr_isBusy) < 0){
		printk(KERN_ALERT "Attribute device creation failed\n");
		return -1;
	} 
	
	// Get data of type IORESOURCE_IRQ(interrupt) from the device-tree
	r_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
	if (!r_irq) {
		printk("no IRQ found\n");
		printk("simpMod at 0x%08x mapped to 0x%08x\n",
			(unsigned int __force)lp->mem_start,
			(unsigned int __force)lp->base_addr);
		
		// Configuring pointers to the IP registers
		regA = (unsigned int __force)lp->base_addr + 0x10;
		regB = (unsigned int __force)lp->base_addr + 0x18;
		regOp = (unsigned int __force)lp->base_addr + 0x20;
		regC = (unsigned int __force)lp->base_addr + 0x28;
		regCrtl = (unsigned int __force)lp->base_addr + 0x00;
		printk("regA: 0x%08x\n",(unsigned int)regA);
		printk("regB: 0x%08x\n",(unsigned int)regB);
		printk("regOp: 0x%08x\n",(unsigned int)regOp);
		printk("regC: 0x%08x\n",(unsigned int)regC);
		printk("regCrtl: 0x%08x\n",(unsigned int)regCrtl); 
		return 0;
	}
	lp->irq = r_irq->start;

	rc = request_irq(lp->irq, &simpMod_irq, 0, DRIVER_NAME, lp);
	if (rc) {
		dev_err(dev, "testmodule: Could not allocate interrupt %d.\n",
			lp->irq);
		goto error3;
	}
	return 0;
error3:
	free_irq(lp->irq, lp);
error2:
	release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
error1:
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return rc;
}

static int simpMod_remove(struct platform_device *pdev){
	struct device *dev = &pdev->dev;
	struct simpMod_local *lp = dev_get_drvdata(dev);
	free_irq(lp->irq, lp);
	release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return 0;
}

// Indicate which type of hardware we handle on this case(simpleAlu-1.0)
#ifdef CONFIG_OF
static struct of_device_id simpMod_of_match[] = {
	{ .compatible = "xlnx,simpleAlu-1.0", },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, simpMod_of_match);
#else
# define simpMod_of_match
#endif


static struct platform_driver simpMod_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= simpMod_of_match,
	},
	.probe		= simpMod_probe, 
	.remove		= simpMod_remove,
};

static int __init simpMod_init(void)
{
	printk("<1>Simple device driver.\n");

	return platform_driver_register(&simpMod_driver);
}

static void __exit simpMod_exit(void)
{
	platform_driver_unregister(&simpMod_driver);
	printk(KERN_ALERT "Goodbye module world.\n");
}

static int dev_open(struct inode *inod, struct file *fil){
	printk(KERN_ALERT "Character device opened\n");
	return 0;
}

// Just send to the user a string with the value of result
static ssize_t dev_read(struct file *fil, char *buf, size_t len, loff_t *off){
	// Return the result only once (otherwise a simple cat will loop)
	if (resp_ready) {
		resp_ready = 0;
		// Copy from kernel space to user space
		printk(KERN_ALERT "Reading device rx: %d\n",(int)len);
		int n = sprintf(ker_buf, "%d\n", result);
		// Copy back to user the result (to,from,size)
		copy_to_user(buf,ker_buf,n);
		printk(KERN_ALERT "Returning %s rx: %d\n",ker_buf,n);
		return n;
	}
	return 0;
}

// Parse the input stream ex: "50,2,*" to some operand variables.
static ssize_t dev_write(struct file *fil, const char *buf, size_t len, loff_t *off){
	// Get data from user space to kernel space
	copy_from_user(ker_buf,buf,len);
	sscanf (ker_buf,"%d,%d,%c",&operand_1,&operand_2,&math_operation);
	ker_buf[len] = 0;
	// Change the IP registers to the parsed operands (on rega and regb)
	*regA = (unsigned int)operand_1;
	*regB = (unsigned int)operand_2;	
	printk(KERN_ALERT "Receiving math operation <%d %c %d>\n",
			      operand_1,math_operation,operand_2);
	return len;
}

static int dev_release(struct inode *inod, struct file *fil){
	printk(KERN_ALERT "Device closed\n");
	return 0;
}

module_init(simpMod_init);
module_exit(simpMod_exit);

